<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Demo Zoom/Pan</title>
  <style>
    #mapaContainer {
    width: 90vw;       /* obliga un límite de ancho */
    height: 88vh;      /* obliga un límite de alto */
    margin: 20px auto;
    overflow: hidden;
    cursor: grab;
    border: 2px solid #333;
    }
    #mapaZoom {
      transform-origin: top left;
      transition: transform 0.1s ease-out;
    }
    #mapaBase {
      display: block;
      width: 100%;
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="mapaContainer">
    <div id="mapaZoom">
      <img id="mapaBase" src="https://raw.githubusercontent.com/Duque-jpg/PlataformaDnD/refs/heads/main/img/mapamundibg.jpg" alt="Mapa">
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
  const cont = document.getElementById("mapaContainer");
  const zoom = document.getElementById("mapaZoom");
  const img  = document.getElementById("mapaBase");

  let scale = 1, panX = 0, panY = 0;
  let dragging = false, startX = 0, startY = 0;

  cont.addEventListener("wheel", e => {
    e.preventDefault();
    // zoom hacia cursor (opcional)
    const prev = scale;
    const rect = cont.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    // ahora bloqueamos el zoom mínimo en 1
scale += e.deltaY < 0 ? 0.1 : -0.1;
scale = Math.min(Math.max(scale, 1), 3);


    // mantengo cursor fijo
    panX -= (mx / prev) * (scale - prev);
    panY -= (my / prev) * (scale - prev);

    clampAndApply();
  });

  cont.addEventListener("mousedown", e => {
    dragging = true;
    startX = e.clientX - panX;
    startY = e.clientY - panY;
    cont.style.cursor = "grabbing";
  });

  cont.addEventListener("mousemove", e => {
    if (!dragging) return;
    panX = e.clientX - startX;
    panY = e.clientY - startY;
    clampAndApply();
  });

  ["mouseup","mouseleave"].forEach(evt =>
    cont.addEventListener(evt, () => {
      dragging = false;
      cont.style.cursor = "grab";
    })
  );

  function clampAndApply() {
  // 1) Medimos solo ANCHO y ALTO base de la imagen (escala = 1)
  const baseW = img.clientWidth;
  const baseH = img.clientHeight;

  // 2) Escalamos esos valores
  const iw = baseW * scale;
  const ih = baseH * scale;

  // 3) Medimos el contenedor
  const cw = cont.clientWidth;
  const ch = cont.clientHeight;

  // 4) Calculamos panX y panY nuevos según situación
  let newPanX, newPanY;

  if (iw <= cw) {
    // Imagen más chica: centramos
    newPanX = (cw - iw) / 2;
  } else {
    // Imagen más ancha: clampeamos entre [cw - iw, 0]
    newPanX = Math.min(Math.max(panX, cw - iw), 0);
  }

  if (ih <= ch) {
    newPanY = (ch - ih) / 2;
  } else {
    newPanY = Math.min(Math.max(panY, ch - ih), 0);
  }

  // 5) Guardamos y aplicamos
  panX = newPanX;
  panY = newPanY;
  zoom.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
}


});
  </script>
</body>
</html>
